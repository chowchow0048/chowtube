<setup>
1. npm init

2. "scripts" in package.json, npm run "script"
    "scripts": "something" >> npm run something >> something에 할당된 script 실행
    npm i : npm install

3. npm i : npm은 package.json의 "dependencies"를 보고 package를 그에 맞게 알아서 install해준다
    package-lock.json은 프로젝트 실행에 필요한 package들을 상세하게 기록해놈, version, resloved, integrity등등
    다른사람에게 프로젝트를 전달해 줄 때, package.json, package-lock.json, index.js(프로젝트 실행 파일)을 보내주고 npm i를 실행하면
    받은사람은 나와 같은 버전의 프로젝트를 실행할 수 있게됨

4. babel: nodejs가 알아듣게 최신버전의 JS로 번역해주는 패키지
    devDependencies: 개발자에게 필요한 패키지
    preset: babel을 위한 아주 큰 플러그인
    @babel/preset-env: smart preset, 최신 JS구문을 사용할 수 있게 해줌
    babel 설정: babel.config.json

5. babel 실행: babel-node index.js
    nodemon: nodemon --exec ~

<introduction to Express>
1. const app = express(); : express 객체 생성
    app.request(port#, callFunction); : express를 통해 서버로 요청보냄

2. const PORT = 4000; : 상수 PORT 4000
    console.log(`server listening on port http://localhost:${PORT}`); : 백틱(₩) 쓰면 포멧지정 출력 가능, ${변수 or 상수}
    / == root page, root server등등 메인이자 첫번째 웹페이지
    http GET : get me this page
    app.get(URL, function); : URL에 request가 있을 때 실행할 function을 정해서 실행

3. app.get()의 함수들, req, res 객체

    const handleLogin = (req, res) => {
        return res.send("Login here.);
    }
    const handleHome = (req, res) => {
        return res.send("I LOVE YOU");
    }

4. 백엔드 개발자: 서버의 request에 대답해준다 response 해준다.

5. middleware = software in the middle
    middleware는 req, res와 next라는 매개변수를 갖는 controller
    next()는 middleware다음의 함수를 부른다
    middleware는 필요한 만큼 만들 수 있음
    middleware는 .use를 통해 모든 url에 쓰일수도, 하나의 url에만 사용될 수도 있음

6. app.use() : ()안에 있는 함수를 서버가 켜졌을 때 실행, 순서에 따라 실행이 안 될 수도있으므로 순서가 중요
    path(route, url) - middleware - finalware 순으로 실행

7. recap - setup
    npm: directory에 package.json이 있는상태에서 npm i 를 돌리면 dependencies에 맞게 package를 받아줌
    babel: ES6의 최신 코드로 JS 파일을 변환시켜서 node가 ES6로 이해하게 하는 package
    nodemon: 서버 끌 필요없이 변화하는대로 반영

8. recap - servers
    server : 항상 켜져있고 인터넷에 연결되어있으면서 request를 listening하는 컴퓨터
    app = express()
    app.listen(PORT, controller)
    app.get(URL, ...controller)
    app.use(middleware)
    controller = (req, res) => {function}
    middleware = (req, res, next) => {function, next()}

9. recap - controllers
10. recap - middleware

11. external middleware
    morgan: middleware package
    morgan("dev"): method, URL, status code, 걸린시간 표기
    "dev", "tiny", "combined", "common", "short" 등등 많은 표기방식이 있음

<Routers>
1. 2 domains, users and videos

2. express.Router()를 통해 router 설정
    globalRouter = express.Router()
    userRouter = express.Router()
    videoRouter = express.Router()
    
    Router설정 후, app.use()를 통해 URL과 router를 이어준다
    app.use("/", globalRouter);
    app.use("/users", userRouter);
    app.use("/videos", videoRouter);

    이후에 각 라우터 마다 하위 패스에 대한 라우팅 설정
    globalRouter.get("/", handleHome);
    userRouter.get("/edit", handleEdit); >> /users/edit 에 들어가면 handleEdit을 실행
    videoRouter.get("/watch", handleWatch); >> /videos/watch 에 들어가면 handleWatch를 실행
    
    이번 강의의 키는 세부패스에 대한 설정을 한 적이 없다는거임
    /users/edit에 대한 설정을 한 적은 없지만 userRouter -> /edit의 경로를 통해 함수실행이 이어짐

3. Cleaning the code
    Divide and Conquer
    모든 파일은 하나의 모듈이다
    모든 파일은 독립적이다
    한 파일안에서도 돌아가는 환경을 코드로 만들어야한다

    export default globalRouter;
    export default userRouter;
    export default videoRouter;

    import globalRouter from '../routers/globalRouter'
    import userRouter from '../routers/userRouter'
    import videoRouter from '../routers/videoRouter'

4. export vs export default
    export default
        - import할 때 객체의 이름을 변경할 수 있음
        - 하나의 객체만 export 가능
    export
        - import할 때 객체의 이름을 변경할 수 없음
        - 다수의 객체를 export 가능

5. Recap - router

6. Recap - architecture

7. Planning Routers
    more specificated routing paths(URLs)

8. URL parameters 1
    /: >> URL에 parameter(매개변수)를 넣는 기호, /: 이후에 / 전까지의
    텍스트를 변수로 사용할 수 있음
    코드로 어떻게 사용? >> req.params.~, ~ 부분은 id, potato 등등 변수같이
    사용자가 지정한 parameter이름을 써줘야함
    * 만약 '/:~' path를 parameter가 없는 다른 path보다 위에 넣으면
      다른 원래 존재하는 path들은 지정한 path name이 parameter로 쓰일 수 있음
      >> '/:~' path는 가장 밑에 몰아넣는다, 충돌이 일어나지 않게끔

9. URL parameters 2
    regular expression: 정규 표현식
        1. /ab?cd : acd or abcd, 선택적 표현
        2. /ab*cd : abasdfracd or ab123cd, 중간에 무한 표현
        3. /ab+cd : abcd or abbcd or abbbcd ... , 선택적 무한 표현(최소1)
        4. /ab(cd)?e : abe or abcde, 집단 선택적 표현

<Templates>
1. Returning HTML
    res.send("<!DOCTYPE html> ~~~") 이렇게 HTML을 보낼 수 있음
    근데 이건 너무 불편함, 긴급상황에서만 쓸모있음
    그래서 우리는 pug가 필요함

2. Configuring  pug
    pug: template engine
    step 1. install pug
    step 2. set view engine as pug
    step 3. make pug files

    app.set("view engine", "pug") >> view engine을 pug로 set
    views 폴더에 home.pug 생성
    res.render("home") >> res.render는 첫번째 스트링을 views폴더에서
    찾아서 리턴함

    process.cwd() == current working directory, 현재 작업 영역
    은 서버를 기동하는 파일의 위치에 따라 결정된다, 어디서 노드를 부르고 있는지에 따라 결정된다
    package.json이 node.js를 실행하고 있음
    app.set("views", process.cwd() + "/src/views"); >> views 경로 설정

    pug: html인데 태그에 <>를 안씌우고 대충 띄어쓰기로 대체하는듯

3. Partials
    pug로 만든 html template들은 이것저것 활용할 수 있는게 많음
    partials: 코드의 반복을 줄이기 위해 특정 부분을 따로 작은template을 만들어둬서 다른 template에 결합시킨다

4. Extending Templates
    partial는 작은 template을 만들어서 부품같이 사용하는거였지만 
    extend, 즉 상속 기능을 사용하면 좀 더 많은 부분의 재사용을 줄일 수 있음
    extends ~~.pug 이런식으로 사용함 >> html의 base template을 가질 수 있게하는 중요한 기능!

    extend한 파일은 block을 통해 개별적인 content를 가질 수 있다
    base 파일에 block부분은 extend받은 파일마다 개별적인 content로 설정할 수 있음

5. Variables to Templates
    html에 JavaScript 변수 넣기 >> #{변수이름}
    html template에 있는 JS변수는 어디로 부터 값을 받을까? >> controller로 부터
    home에 경우, videoController의 trending() 으로부터 render되므로
    res.render("home", {변수이름: 넣을 값}); >> 이런 식으로, 마치 dictionary 자료형에서 "name": "value" 이렇게 넣어주듯이 넣어줌

6. Recap

7. MVP Styles
    MVP.css 라는 간단한 css적용
    head 밑에 <link rel="stylesheet" href="https://unpkg.com/mvp.css@1.12/mvp.css"> 여기서 
    link(rel="stylesheet" href="https://unpkg.com/mvp.css@1.12/mvp.css") 꺽쇠 떼고 ()붙여주면 댐

8. Conditionals
    h1=pageTitle 이거랑
    h1 #{pageTitle} 이거랑 같은데 Nico는 위에걸 선호한다캄, 왜냐?
    #{} 이거는 다른 text랑 변수랑 구분짓기 위해서 써주는거고, 변수하나만
    달랑 있는애들은 h1=변수 이렇게 쓰는게 맞다캄, 근데 나는 혼동올거같아서
    한 방법만 쓰고싶은딩..

    body
        header
            nav
                ul
                    li
                        a(href="/login") Login
    
    conditionals: if/else if/else
    pug를 통해 html에서도 조건문을 쓸 수있음
    예시, fakeUser라는 구조체를 JS로 부터 받고,fakeUser의 멤버를 통해 html 조건문 실행
    const fakeUser = {
        userName: "Tom",
        loggedIn: false,
    };

    const home = (req, res) => res.render("home", {pageTitle: "home", fakeUser});

    head
    body
        header
            if fakeUser.loggedIn
                small Hello #{fakeUser.userName}
            nav
                ul
                    if fakeUser.loggedIn
                        li
                            a(href="/logout") Log out
                    else
                        li 
                            a(href="/login") Log in

9. Iteration
    pug에서 iteration(반복문) 사용가능
    controller에서 view template에게 array형태의 자료를 넘겨주면
    template에서 그걸 반복문으로 사용할 수 있다

    const videos = [1, 2, 3, 4, 5];
    res.render('home', {videos});
     이런식으로 array만들어서 넘겨주면

    block content
        ul
            each video in videos
                li=video
    이렇게 하면 videos의 원소들을 li로 갖는 ul이 생성됨

    each video in videos
        li=video
    else
        li There is no content
    반복문은 조건문이랑도 같이 쓸 수 있다
    만약 넘겨준 videos array가 비어있으면 else로 넘어가서
    There is no content라는 li가 화면에 나타날거임

10. Mixins
    mixin은 좀 똑똑한 partial이다
    mixin은 partial처럼 한 template의 부분으로 결합되어 작동하지만
    변수를 받아서 사용할 수 있고, 반복문과 결합해서 사용할 수 있기 때문에
    좀 더 다양한 표현을 가능하게 한다

    1.mixins 폴더를 만들고 
    2.mixin 파일을 만들고
    3.mixin 파일 안에 실행할 로직을 만들어주고
    4.mixin 로직을 사용할 template에 설치를 해주면 됨

    1.mixins/video.pug 생성
    2 and 3.
        mixin video(info) 
            div
                h4=info.title
                ul
                    li #{info.asasdf}~~
                    li #{info.asgasrn}~~
                    ~~~~
    대략적인 mixin 파일의 생김새는 이렇다
    mixin 이름(인자 이름)
        로직
    
    4. 설치
    include mixins/video

    each info in videos
        +video(info)

    include mixins/mixin파일이름
    +mixin이름(인자 이름)

11. Recap
    learned about Templates
    partials
    conditionals
    iterations
    mixins

<MongoDB and Mongoose>
1. Array DB 1
    pug에서도 `${}` 의 포멧 지정형식 출력을 사용할 수 있다
    `asdf ${video}` == "asdf" + video , 같은거래

2. ArrayDB 2
    절대경로 absoluteURL: "/profile/edit-profile/password" >> /가 맨앞에 있으면 root에 URL을 붙인 경로로 간다
                >> "localhost:4000/profile/edit-profile/password"
    상대경로 relativeURL: "potato" >> /가 맨앞에 없으면 현재 경로에서 마지막 부분을 바꾼 경로로 들어간다
                >> "localhost:4000/profile/edit-profile/password" 에서 "potato"로 가는 URL을 타면
                >> "localhost:4000/profile/edit-profile/potato" 로 간다
    삼항연산자 Ternary operator, html도 삼항연산자를 쓸 수 있는듯
    ex) h3 #{video.views} #{video.views === 1 ? "view":"views"}
                            video.view의 값이 1이면 "view"가 되고, 
                            video.view의 값이 1이 아니면 "views"가 된다
3. Edit video 1
    get, post
    videoRouter.get("/asdf", controller)
    videoRouter.post("/asdf", contorller) >> 서버가 post를 이해할 수 있게됐다
    get과 post의 차이
    사용 목적: get은 서버의 리소스에서 data를 요청할 때
            post는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용
            get은 DB로 따지면 SELECT에 가깝고, POST는 CREATE에 가깝다

4. Edit video 2
    get으로 데이터를 요청하고, post로 데이터를 수정, 추가, 삭제 한다
    app.use(express.urlencoded({extended: true}));
    form - input - submit - post request - post controller - req.body 
    순서대로 진행됨. post controller에서  post request를 통해 얻은 req.body 데이터를 처리하게됨

5. Recap

6. More Practice 1

7. More Practice 2

8. introduction to MongoDB

9. Connectinc to MongoDB

10. CRUD introduction

11. Video Model

12. Our First Query 2

13. Async Await

14. Returns and Renders

15. Creating a Video 1

16. Cfeating a Video 2

17. Ecexptions and Validation

18. More Schema

19. Video Detail

20. Edit video 1

21. Edit video 2

22. Edit video 3

23. Middlewares

24. Statics

25. Delete video

26. Search 1

27. Search 2

28. Conclusions



check git commit