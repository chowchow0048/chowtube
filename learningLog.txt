<setup>
1. npm init

2. "scripts" in package.json, npm run "script"
    "scripts": "something" >> npm run something >> something에 할당된 script 실행
    npm i : npm install

3. npm i : npm은 package.json의 "dependencies"를 보고 package를 그에 맞게 알아서 install해준다
    package-lock.json은 프로젝트 실행에 필요한 package들을 상세하게 기록해놈, version, resloved, integrity등등
    다른사람에게 프로젝트를 전달해 줄 때, package.json, package-lock.json, index.js(프로젝트 실행 파일)을 보내주고 npm i를 실행하면
    받은사람은 나와 같은 버전의 프로젝트를 실행할 수 있게됨

4. babel: nodejs가 알아듣게 최신버전의 JS로 번역해주는 패키지
    devDependencies: 개발자에게 필요한 패키지
    preset: babel을 위한 아주 큰 플러그인
    @babel/preset-env: smart preset, 최신 JS구문을 사용할 수 있게 해줌
    babel 설정: babel.config.json

5. babel 실행: babel-node index.js
    nodemon: nodemon --exec ~

<introduction to Express>
1. const app = express(); : express 객체 생성
    app.request(port#, callFunction); : express를 통해 서버로 요청보냄

2. const PORT = 4000; : 상수 PORT 4000
    console.log(`server listening on port http://localhost:${PORT}`); : 백틱(₩) 쓰면 포멧지정 출력 가능, ${변수 or 상수}
    / == root page, root server등등 메인이자 첫번째 웹페이지
    http GET : get me this page
    app.get(URL, function); : URL에 request가 있을 때 실행할 function을 정해서 실행

3. app.get()의 함수들, req, res 객체

    const handleLogin = (req, res) => {
        return res.send("Login here.);
    }
    const handleHome = (req, res) => {
        return res.send("I LOVE YOU");
    }

4. 백엔드 개발자: 서버의 request에 대답해준다 response 해준다.

5. middleware = software in the middle
    middleware는 req, res와 next라는 매개변수를 갖는 controller
    next()는 middleware다음의 함수를 부른다
    middleware는 필요한 만큼 만들 수 있음
    middleware는 .use를 통해 모든 url에 쓰일수도, 하나의 url에만 사용될 수도 있음

6. app.use() : ()안에 있는 함수를 서버가 켜졌을 때 실행, 순서에 따라 실행이 안 될 수도있으므로 순서가 중요
    path(route, url) - middleware - finalware 순으로 실행

7. recap - setup
    npm: directory에 package.json이 있는상태에서 npm i 를 돌리면 dependencies에 맞게 package를 받아줌
    babel: ES6의 최신 코드로 JS 파일을 변환시켜서 node가 ES6로 이해하게 하는 package
    nodemon: 서버 끌 필요없이 변화하는대로 반영

8. recap - servers
    server : 항상 켜져있고 인터넷에 연결되어있으면서 request를 listening하는 컴퓨터
    app = express()
    app.listen(PORT, controller)
    app.get(URL, ...controller)
    app.use(middleware)
    controller = (req, res) => {function}
    middleware = (req, res, next) => {function, next()}

9. recap - controllers
10. recap - middleware

11. external middleware
    morgan: middleware package
    morgan("dev"): method, URL, status code, 걸린시간 표기
    "dev", "tiny", "combined", "common", "short" 등등 많은 표기방식이 있음

<Routers>
1. 2 domains, users and videos

2. express.Router()를 통해 router 설정
    globalRouter = express.Router()
    userRouter = express.Router()
    videoRouter = express.Router()
    
    Router설정 후, app.use()를 통해 URL과 router를 이어준다
    app.use("/", globalRouter);
    app.use("/users", userRouter);
    app.use("/videos", videoRouter);

    이후에 각 라우터 마다 하위 패스에 대한 라우팅 설정
    globalRouter.get("/", handleHome);
    userRouter.get("/edit", handleEdit); >> /users/edit 에 들어가면 handleEdit을 실행
    videoRouter.get("/watch", handleWatch); >> /videos/watch 에 들어가면 handleWatch를 실행
    
    이번 강의의 키는 세부패스에 대한 설정을 한 적이 없다는거임
    /users/edit에 대한 설정을 한 적은 없지만 userRouter -> /edit의 경로를 통해 함수실행이 이어짐

3. Cleaning the code
    Divide and Conquer
    모든 파일은 하나의 모듈이다
    모든 파일은 독립적이다
    한 파일안에서도 돌아가는 환경을 코드로 만들어야한다

    export default globalRouter;
    export default userRouter;
    export default videoRouter;

    import globalRouter from '../routers/globalRouter'
    import userRouter from '../routers/userRouter'
    import videoRouter from '../routers/videoRouter'

4. export vs export default
    export default
        - import할 때 객체의 이름을 변경할 수 있음
        - 하나의 객체만 export 가능
    export
        - import할 때 객체의 이름을 변경할 수 없음
        - 다수의 객체를 export 가능

5. Recap - router

6. Recap - architecture

7. Planning Routers
    more specificated routing paths(URLs)

8. URL parameters 1
    /: >> URL에 parameter(매개변수)를 넣는 기호, /: 이후에 / 전까지의
    텍스트를 변수로 사용할 수 있음
    코드로 어떻게 사용? >> req.params.~, ~ 부분은 id, potato 등등 변수같이
    사용자가 지정한 parameter이름을 써줘야함
    * 만약 '/:~' path를 parameter가 없는 다른 path보다 위에 넣으면
      다른 원래 존재하는 path들은 지정한 path name이 parameter로 쓰일 수 있음
      >> '/:~' path는 가장 밑에 몰아넣는다, 충돌이 일어나지 않게끔

9. URL parameters 2
    regular expression: 정규 표현식
        1. /ab?cd : acd or abcd, 선택적 표현
        2. /ab*cd : abasdfracd or ab123cd, 중간에 무한 표현
        3. /ab+cd : abcd or abbcd or abbbcd ... , 선택적 무한 표현(최소1)
        4. /ab(cd)?e : abe or abcde, 집단 선택적 표현

<Templates>
1. Returning HTML
    res.send("<!DOCTYPE html> ~~~") 이렇게 HTML을 보낼 수 있음
    근데 이건 너무 불편함, 긴급상황에서만 쓸모있음
    그래서 우리는 pug가 필요함

2. Configuring  pug
    pug: template engine
    step 1. install pug
    step 2. set view engine as pug
    step 3. make pug files

    app.set("view engine", "pug") >> view engine을 pug로 set
    views 폴더에 home.pug 생성
    res.render("home") >> res.render는 첫번째 스트링을 views폴더에서
    찾아서 리턴함

    process.cwd() == current working directory, 현재 작업 영역
    은 서버를 기동하는 파일의 위치에 따라 결정된다, 어디서 노드를 부르고 있는지에 따라 결정된다
    package.json이 node.js를 실행하고 있음
    app.set("views", process.cwd() + "/src/views"); >> views 경로 설정

    pug: html인데 태그에 <>를 안씌우고 대충 띄어쓰기로 대체하는듯

3. Partials
    pug로 만든 html template들은 이것저것 활용할 수 있는게 많음
    partials: 코드의 반복을 줄이기 위해 특정 부분을 따로 작은template을 만들어둬서 다른 template에 결합시킨다

4. Extending Templates
    partial는 작은 template을 만들어서 부품같이 사용하는거였지만 
    extend, 즉 상속 기능을 사용하면 좀 더 많은 부분의 재사용을 줄일 수 있음
    extends ~~.pug 이런식으로 사용함 >> html의 base template을 가질 수 있게하는 중요한 기능!

    extend한 파일은 block을 통해 개별적인 content를 가질 수 있다
    base 파일에 block부분은 extend받은 파일마다 개별적인 content로 설정할 수 있음

5. Variables to Templates
    html에 JavaScript 변수 넣기 >> #{변수이름}
    html template에 있는 JS변수는 어디로 부터 값을 받을까? >> controller로 부터
    home에 경우, videoController의 trending() 으로부터 render되므로
    res.render("home", {변수이름: 넣을 값}); >> 이런 식으로, 마치 dictionary 자료형에서 "name": "value" 이렇게 넣어주듯이 넣어줌

6. Recap

7. MVP Styles
    MVP.css 라는 간단한 css적용
    head 밑에 <link rel="stylesheet" href="https://unpkg.com/mvp.css@1.12/mvp.css"> 여기서 
    link(rel="stylesheet" href="https://unpkg.com/mvp.css@1.12/mvp.css") 꺽쇠 떼고 ()붙여주면 댐

8. Conditionals
    h1=pageTitle 이거랑
    h1 #{pageTitle} 이거랑 같은데 Nico는 위에걸 선호한다캄, 왜냐?
    #{} 이거는 다른 text랑 변수랑 구분짓기 위해서 써주는거고, 변수하나만
    달랑 있는애들은 h1=변수 이렇게 쓰는게 맞다캄, 근데 나는 혼동올거같아서
    한 방법만 쓰고싶은딩..

    body
        header
            nav
                ul
                    li
                        a(href="/login") Login
    
    conditionals: if/else if/else
    pug를 통해 html에서도 조건문을 쓸 수있음
    예시, fakeUser라는 구조체를 JS로 부터 받고,fakeUser의 멤버를 통해 html 조건문 실행
    const fakeUser = {
        userName: "Tom",
        loggedIn: false,
    };

    const home = (req, res) => res.render("home", {pageTitle: "home", fakeUser});

    head
    body
        header
            if fakeUser.loggedIn
                small Hello #{fakeUser.userName}
            nav
                ul
                    if fakeUser.loggedIn
                        li
                            a(href="/logout") Log out
                    else
                        li 
                            a(href="/login") Log in

9. Iteration
    pug에서 iteration(반복문) 사용가능
    controller에서 view template에게 array형태의 자료를 넘겨주면
    template에서 그걸 반복문으로 사용할 수 있다

    const videos = [1, 2, 3, 4, 5];
    res.render('home', {videos});
     이런식으로 array만들어서 넘겨주면

    block content
        ul
            each video in videos
                li=video
    이렇게 하면 videos의 원소들을 li로 갖는 ul이 생성됨

    each video in videos
        li=video
    else
        li There is no content
    반복문은 조건문이랑도 같이 쓸 수 있다
    만약 넘겨준 videos array가 비어있으면 else로 넘어가서
    There is no content라는 li가 화면에 나타날거임

10. Mixins
    mixin은 좀 똑똑한 partial이다
    mixin은 partial처럼 한 template의 부분으로 결합되어 작동하지만
    변수를 받아서 사용할 수 있고, 반복문과 결합해서 사용할 수 있기 때문에
    좀 더 다양한 표현을 가능하게 한다

    1.mixins 폴더를 만들고 
    2.mixin 파일을 만들고
    3.mixin 파일 안에 실행할 로직을 만들어주고
    4.mixin 로직을 사용할 template에 설치를 해주면 됨

    1.mixins/video.pug 생성
    2 and 3.
        mixin video(info) 
            div
                h4=info.title
                ul
                    li #{info.asasdf}~~
                    li #{info.asgasrn}~~
                    ~~~~
    대략적인 mixin 파일의 생김새는 이렇다
    mixin 이름(인자 이름)
        로직
    
    4. 설치
    include mixins/video

    each info in videos
        +video(info)

    include mixins/mixin파일이름
    +mixin이름(인자 이름)

11. Recap
    learned about Templates
    partials
    conditionals
    iterations
    mixins

<MongoDB and Mongoose>
1. Array DB 1
    pug에서도 `${}` 의 포멧 지정형식 출력을 사용할 수 있다
    `asdf ${video}` == "asdf" + video , 같은거래

2. ArrayDB 2
    절대경로 absoluteURL: "/profile/edit-profile/password" >> /가 맨앞에 있으면 root에 URL을 붙인 경로로 간다
                >> "localhost:4000/profile/edit-profile/password"
    상대경로 relativeURL: "potato" >> /가 맨앞에 없으면 현재 경로에서 마지막 부분을 바꾼 경로로 들어간다
                >> "localhost:4000/profile/edit-profile/password" 에서 "potato"로 가는 URL을 타면
                >> "localhost:4000/profile/edit-profile/potato" 로 간다
    삼항연산자 Ternary operator, html도 삼항연산자를 쓸 수 있는듯
    ex) h3 #{video.views} #{video.views === 1 ? "view":"views"}
                            video.view의 값이 1이면 "view"가 되고, 
                            video.view의 값이 1이 아니면 "views"가 된다
3. Edit video 1
    get, post
    videoRouter.get("/asdf", controller)
    videoRouter.post("/asdf", contorller) >> 서버가 post를 이해할 수 있게됐다
    get과 post의 차이
    사용 목적: get은 서버의 리소스에서 data를 요청할 때
            post는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용
            get은 DB로 따지면 SELECT에 가깝고, POST는 CREATE에 가깝다

4. Edit video 2
    get으로 데이터를 요청하고, post로 데이터를 수정, 추가, 삭제 한다
    app.use(express.urlencoded({extended: true}));
    form - input - submit - post request - post controller - req.body 
    순서대로 진행됨. post controller에서  post request를 통해 얻은 req.body 데이터를 처리하게됨

5. Recap

6. More Practice 1
    recap 강의.
    controller - route - template
    controller: (req,res) => {res.render(template, {pageTitle: "Upload Video})};
    route: .route(path).get(controller).post(controller);
    template: extend base, block content form(method="POST")
                                            input(placeholder="Title", required, type="text")
                                            input(type="submit", value="Upload Video")


7. More Practice 2
    recap 강의
    videos 배열에 newVideo를 push
    form(method="POST", action="/videos/upload")
        input(name="title", placeholder="Title", required, type="text")
        input(type="submit", value="Upload Video")
    title 입력하고 submit버튼 누르면
    postUpload controller에 의해
    const newVideo = {title, rating, comment, ... };
    videos.push(newVideo);
    res.redirect("/");

8. introduction to MongoDB
    mongodb 설치 homebrew로 설치함

9. Connectinc to MongoDB
    mongod -> mongosh : mongoDB쓰는 mongo shell로 연결
    show dbs, show users등 커맨드 수행 가능
    
    1. import mongoose from "mongoose";
    2. mongoose.set('strictQuery', true);
    3. mongoose.connect("mongodb://127.0.0.1:27017/chowtube", {
        useNewUrlParser: true,
        useUnifiedTopolgy: true
    });
    4. const db = mongoose.connection;
    5. db.on("error", handleError);
    6. db.once("open", handleOpen);

    db.on은 조건만족시 마다 지정한 controller 수행
    db.once는 조건만족시 한번 지정한 controller 수행

    위에 만들어준 db.js파일을 server와 연결하는법
    1. server.js에서 import './db';
    2. 끝

10. CRUD introduction
    Create Read Upload Delete, CRUD
    module: DB에게 어떤 형태의 data를 줄것이라 알려주는 형식을가진 파일

11. Video Model
    shape of the data: Schema, via schema we make model
    const videoSchema = new mongoose.Schema({});
    const movieModel = mongoose.model("name", videoSchema);

    db를 mongoose와 연결시켜서 video model을 인식시킨다

12. Our First Query 
    server.js에서 app.listen()으로 서버를 작동하는 부분을 init.js로 분할
    db와 mongoose의 소통을 위해 만든 model을 사용하는 방법에는 두가지가 있다
    1. callback
        js에서 기다림을 표현하는 방법중 하나, 연결이 확인되면 특정 function이 발동하는 app.listen같은것
        configuration과 functio이 필요함
    2. promise

    기본적인 model.find()의 형식: model.find({찾을 data 형식}, callback);

13. Our First Query 2
    model.find()는 server밖에있는 db속에서 data를 찾는것이기 때문에 시간이 더 걸림
    그래서 다른 작업에 비해 늦게 끝남
    callback: 파라미터로 전달받은 함수, 

13. Async Await
    callback function 의 장점은 에러들을 바로 볼 수 있다는것
    하지만 js의 단점은 기다리는 기능이 없어서 아무리 위에서 아래로 읽어도 database에서 불러오는 시간이 있어서 순서가 꼬인다 그래서 callback function을 썼었다.
    하지만 await,async가 생기면서 달라졌다!!
    await는 database에게 결과값을 받을때까지 js가 기다리게 해줄 수 있다..!!
    await,async의 장점은 매우 직관점이라는것 즉 js 가 어디서 어떻게 기다리는지 알 수 있다
    await는 규칙상 function이 async 상태일때만 안에서 사용 가능!
    하지만 callback function과 달리 promise방식은 error 가 어디서 오는지 명확하지가 않다
    그래서 try catch 방법을 쓴다
    말그대로 try 안에 있는 코드를 실행해보고 오류가 생기면 catch 안에 코드가 실행되는구조

    핵심 코드
    video.find({}, (error, videos) => {
        if(error){
            return res.render("server-error")
        }
        return res.render("home")
    });

14. Returns and Renders
    1. return의 역할 : 본질적인 return의 역할보다는 function을 마무리짓는 역할로 사용되고 있음.
    - 이러한 경우 return이 없어도 정상적으로 동작하지만 실수를 방지하기 위해 return을 사용
    2. render한 것은 다시 render할 수 없음
    - redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)

    C#에서 async 와 await를 생각 하시면 쉬울듯 합니다.
    비동기를 동기적으로 동작하는 것 처럼 보여주는게 아니고
    저 코드 자체가 비동기 동작 코드 입니다.
    async는 "애들아 이 함수에는 뭔가 약간 구린 코드가 있어
    그러니까 일단 내 볼일 볼때까지 그냥 니들일은 알아서들
    하고 있엉~~"
    await는 "ㅋㅋㅋ 내가 바로 그 구린녀석이다. 나도 내할일 하고
    나서 결과 줄테니까 다른 넘들은 다 각자 할일 하고 있고
    단 내뒤에 있는 넘들은(비동기 함수내에 있는 내뒤에 코드들임, 다른 함수들은 뒤에 있어도 비동기기 때문에 이미 실행됨) 일단 대기타라."
    이렇게 이해 하시면 쉬울듯 합니다.
    애초에 Nodejs는 내부 구조가 이렇게 되어 있어서, 그런 구조로 프로그래밍 할일은 없지만, 유저 한명이 100000기가바이트짜리
    데이터를 불러 온다고 해도, 그 뒤에 유저들이 다 "멍~~~" 하는게
    아니라, 저 유저의 데이터 처리는 뒤에서 따로 하고 나머지는
    비동기로 싹 처리해 줍니다. 즉 싱글 쓰레드지만, 순식간에
    번갈아 가면서 처리하면서 왔다리 갔다리 하기 때문에
    우리는 잘 못느낌니다.
    다만, 첫번째 유저가 쓰레드 자체를 혼자 완전히 독차지할
    때보다는 불러오는 속도는 느리겠지요,

15. Creating a Video 1
    video를 만들기 위해선 document를 만들어줘야함, document는 데이터를 가진 비디오라고 생각
    JS문법: split
        "abc, def, jpg".split(',') >>> ['abc', 'def', 'jpg']
        "abc, def, jpg".split(',').map((word) => `#${word}`) >>> ['#abc', '#def', '#jpg']

    const video = new Video({
        title,
        description,
        createdAt: Date.now(),
        hashtags: hashtags.split(",").map((word)=>`#${word}`),
        meta:{
            views: 0,
            rating: 0
        }
    })

    위의 video 도큐먼트는 module로 만들어둔 mongoDB의 Video schema를 따라서 만드는거임

16. Creating a Video 2
    mongoose는 데이터 타입의 유효성을 검사한다
    schema에 설정한 데이터 타입과 다른 타입의 데이터가 도큐먼트에 들어왔을 때,
    그 데이터는 mongoose에 의해 유실된다
        - 설정해둔 데이터보다 더 많은 종류의 데이터가 들어오면? 그럴경우가 있나?
    
    video.save(): promise를 return한다, save는 mongoose의 함수이다
        promise를 return한다는 말은, save작업이 끝날 때까지 기다려줘야 한다는 것
        async, await를 사용하여 save 작업을 수행하는 시간을 준다

    이후 데이터를 입력하고 submit하면 home화면에 만든 video 데이터가 출력된다
    schema 작성 - controller 생성(postUpload: model.save(), home: model.find()) - route(path)생성 - template 생성(도큐먼트를 나타낼 template)

    video 도큐먼트를 만드는 또다른 방법)
    Video.create({
        title,
        description,
        createdAt: Date.now(),
        hashtags: hashtags.split(",").map((word) => `#${word}`),
        meta:{
            views: 0,
            rating: 0,
        },
    });
    >>> model.create() (mongoose 문법임)

17. Ecexptions and Validation
    validation error: schema와 다른 타입의 데이터를 도큐먼트에 입력했을 때 발생, required인 데이터타입에 한하여 유효성 검사
    data1: { type: String, reqires: true }, >>> data1은 String타입이고 required이므로 String이 아니거나, 입력되지않으면 error를 return

    try{
        Video.create({
            ~~
        })
    }catch(error){
        res.render("upload",{
            pageTitle: "Upload",
            errorMessage: error._message,
        });
    }
    >>> await되는 코드에 오류가 있다면 JS는 더 이상 코드를 실행시키지 않는다. 그렇기에 try를 넣어서 코드가 멈추는것을 막는다

18. More Schemas
    "h e l l o       .".trim() >>> "hello."
    이 기능을 schema에서도 적용시킬수 있다
    maxLength: 140 >>> 문자열 최대길이 140자(char)
    minLength: 20 >>> 문자열 최소길이 20자(char)

19. Video Detail
    mongoose의 id는 ObjectId로 검색하면 찾을 수 있음
    ObjectId는 16진수 24개로 구성되어있음.
    정규표현식을 통해 URL에서 ObjectId만 따로 빼올 수 있음
    [0-9a-f]{24} >>> ("/:id([0-9a-f]{24})")
    
    const {id} : 변수 밖에 {}로 감싸는건 객체 구조 분해법 이다
    var o = {p: 42, q: true}
    var {p, q} = o;
    console.log(p) >>> 42
    console.log(q) >>> true

    mongoDB에서 model은 다양한 함수를 제공한다
    model.find()도 다양한 변주가 있는데
    그중 model.findById()는 mongoDB가 주는 id값을 기반으로 도큐먼트를 찾는다

20. Edit video 1

21. Edit video 2

22. Edit video 3

23. Middlewares

24. Statics

25. Delete video

26. Search 1

27. Search 2

28. Conclusions
